function DTcones(params)
%
%  DTcones(params)
%
% 'params' should have the following fields:
%
% params.runType            => 'DTNT', 'DTV1', 'absThresh', 'default'
% params.obsMethod          => ideal observer method (e.g., 'obsMethod_all')
% params.impulseResponse    => 'rieke', or 'deltafxn' 
% params.DTV1_fname     	=> name of a DT expt on V1 (.nex file)
% params.DTNT_fname     	=> name of a DTNT batch file
% params.monCalFile     	=> the name of a monitor calibration file (e.g., DTcones.mat)
% params.unitTest       	=> true or false (runs the testing routines)
% params.eqMosaic       	=> true or false (equates the cone mosaics)
% params.saveDir            => path to the directory where data will be saved
% params.notes          	=> a string. notes for the data file that describes the experimental run
% params.parallelOperations => true/false. so that DTcones knows how to store temporary files used during parfor loops
%
% Created by CAH using routines inspired by Juan Angueyra



    %create/initialize the structures that will define the simulation
    [gab, params] = initGabor(params);
    mon = initMonitorCalibration(params, gab);
    cones = initConeMosaic_new(gab, mon);
    if strcmpi(params.runType, 'absthresh'); cones = modifyConeMosaic(cones); end % eliminates all but a few cones
    [cones, gab] = makeConeLinearFilter(params, cones, mon, gab);
    cones = makeConePowerSpectrum(cones, gab);
    mon = getBkgndLinearResp(cones, mon);
    idlob = initIdealObserver(params.obsMethod, gab); %this is where you set which ideal observer will be used

    %stop here and do perform some testing routines if desired
    if params.unitTest
        callAllTestingSubfunctions(gab, mon, cones, params);
        return %exit DTcones
    elseif params.eqMosaic
        [~,cones] = feval(idlob.method, 'equate_mosaic', idlob, gab, cones);
    end

    %loop through each color direction specified. Make a space/time gabor
    %stimulus and determine the output of the cone mosaic. Do this in
    %subfunctions so that the temporary variables created do not clog up
    %the workspace (and eat RAM).
    nColors = size(gab.colorDirs, 1);
    for clr = 1:nColors
        %fprintf('  Color %d of %d\n', clr, nColors);
        nContrasts = size(gab.contrasts{clr},2);

        for cnt = 1:nContrasts
            %fprintf('    Contrast %d of %d\n', cnt, nContrasts);

            % create a gabor movie
            lms_Rstar = getGaborRstar(clr, cnt, gab, mon, params, cones);
            gab.movie = makeGaborMovie(lms_Rstar, gab, mon, 'movie', params); %stimulus movie in 4D [X, Y, Time, Cones], where Cones=3. Should be in units of R*/sec due to the stimulus

            % calculate the linear response of the cones
            cones = coneVolution_FFT(gab, cones, mon);

            % sythesize multipule trials by adding noise to the linear
            % response and then performing the ideal observer analysis
            for trl = 1:gab.nTrials;
                %fprintf('      Trial %d of %d\n', trl, gab.nTrials);
                cones = shapedConeNoise(cones, gab);
                [idlob, cones] = feval(idlob.method, 'compute', idlob, gab, cones, mon, clr, cnt, trl, params); %computes the ideal observer response
            end

            % A new non-MonteCarlo method of determining the variance of
            % the ideal observer.
            [idlob, cones] = feval(idlob.method, 'analytic_solution', idlob, gab, cones, mon, clr, cnt, trl, params);
        end
    end

    %save the results of the experiment in a directory. This directory
    %should contain the results, all relavant simulation structures, AND an
    %exact copy of the code that was run to produce the results. Time stamp
    %the directory name. Re-name the .m file, or add a different extension
    %so that it is identifiable as the actual code run.
    saveDataToDisk(gab, cones, mon, idlob, params)

end



%
%   SUPPORTING FUNCTIONS
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [gab, params] = initGabor(params)
    
    % common to both methods:
    nContrasts = 21;
    gab.nTrials = 0;
    
    switch lower(params.runType)
        
        case 'default'
            gab.sd = 4;           % in 1/10 dva
            gab.nSd = 3;          % number of SDs in gabor
            gab.theta = 0;        % in radians. Zero is horizontal drifting up
            gab.gamma = 1;        % SDx == SDy
            gab.sf = 1;           % in cpd
            gab.driftRate = 3;    % in cyc/sec
            gab.length = 0.666;   % in sec
            gab.rf_x = 50;       % in 1/10 dva
            gab.rf_y = 0;       % in 1/10 dva
            gab.colorDirs = [1, 1, 1;...
                             1, -1, 0;...
                             1, -1, 1;...
                             1, -1, -1;...
                             0, 0, 1];
            cntrsts = [0, logspace(log10(0.00001), log10(0.004), nContrasts)];
            gab.contrasts = repmat({cntrsts}, size(gab.colorDirs,1), 1);
            
        case 'dtv1'
            
            % unpack the .nex file
            DT = dtobj(params.DTV1_fname);
            DT = stripOutGratingTrials(DT);
            if DT.sum.exptParams.expt_meth ~= 1;
                error(' The specified file is not from a MoCS experiment')
            end
            
            %assign the relavant parameters
            gab.sd = unique(DT.trial(:, DT.idx.gaborSigma));
            gab.nSd = DT.sum.exptParams.flash_size;
            gab.theta = unique(DT.trial(:, DT.idx.gaborTheta));
            gab.gamma = unique(DT.trial(:, DT.idx.gaborGamma));
            gab.sf = 1 ./ (unique(DT.trial(:, DT.idx.gaborLambda)) ./ DT.sum.exptParams.pixperdeg);
            gab.driftRate = unique(DT.trial(:, DT.idx.driftRate));
            gab.length = DT.sum.exptParams.flash_length./1000;
            gab.rf_x = DT.sum.exptParams.rf_x;
            gab.rf_y = DT.sum.exptParams.rf_y;
            
            %determine the color directions used
            gab.colorDirs = reshape(DT.sum.exptParams.RF_colors, [], 3)';
            blankIdx = sum(abs(gab.colorDirs), 2) == 0;
            gab.colorDirs(blankIdx,:) = [];
            norms = sqrt(sum(gab.colorDirs.^2,2));
            gab.colorDirs = bsxfun(@rdivide, gab.colorDirs, norms); %now unit vecs
            gab.colorDirs(gab.colorDirs(:,1)<0,:) = -gab.colorDirs(gab.colorDirs(:,1)<0,:); %flip the signs for L-cone weights that were negative
            l_siso = softEq([0,0,1], abs(gab.colorDirs), [], 'rows');
            if sum(gab.colorDirs(l_siso,:)) < 0;
                gab.colorDirs(l_siso,:) = gab.colorDirs(l_siso,:) .* -1;
            end
            
            
            %now determine the rgb's used
            x = 0:255; %the normal range of the gamma look up table
            xx = linspace(0, 255, 2^16); %the desired quantization of the gammaTable
            g1 = reshape(DT.sum.exptParams.gamma_table, 256, 3);
            gammaTable = [spline(x, g1(:,1), xx)', spline(x, g1(:,2), xx)', spline(x, g1(:,3), xx)'];
            M = reshape(DT.sum.exptParams.m_mtx,3,3);
            bkgndrgb = [DT.sum.exptParams.bkgnd_r, DT.sum.exptParams.bkgnd_g, DT.sum.exptParams.bkgnd_b];
            bkgndlms = M * bkgndrgb(:);
            for clr  = unique(DT.trial(:, DT.idx.colorDir))'
                for cnt = unique(DT.trial(:, DT.idx.cntrstLev))'
                    if cnt == 1
                        tList = DT.trial(:, DT.idx.cntrstLev) == cnt;
                    else
                        tList = (DT.trial(:, DT.idx.colorDir) == clr) & (DT.trial(:, DT.idx.cntrstLev) == cnt);
                    end
                    
                    %pull out the RGB for this clr/contrast
                    RGB = unique(DT.trial(tList, [DT.idx.flashR, DT.idx.flashG, DT.idx.flashB]), 'rows');
                    if size(RGB, 1) ~= 1; error('more than one RGB per color direction'); end
                    rgb = [gammaTable(RGB(1), 1), gammaTable(RGB(2), 2), gammaTable(RGB(3), 3)];
                    lms = M * rgb(:);
                    gab.V1_CCs{clr}(:,cnt) = norm((lms-bkgndlms)./bkgndlms);
                end
                
                % instead of sampling the same contrasts as the DT expt. Resample a
                % range from very low contrast to the max contrast used in the expt
                gab.contrasts{clr} = [0, logspace(log10(0.00001), log10(0.8 .* max(gab.V1_CCs{clr})), nContrasts)];
            end
            
            % package the stro file (here named 'DT') so that other
            % functions can have access to it
            params.V1stro = DT;
            
        case 'dtnt'
            
            % load the batch dtnt data
            load(params.DTNT_fname);
            in = dtnt;
            
            % specify all the gabor parameters.
            gab.rf_x = in.rf_x;
            gab.rf_y = in.rf_y;
            gab.sd = in.sigma;
            gab.nSd = in.nSD;
            gab.theta = in.theta;
            gab.gamma = in.gamma;
            gab.length = in.length;
            gab.driftRate = in.speed;
            
            gab.colorDirs = in.colorDirs;
            gab.sf = in.sfs;
            gab.contrasts = {};
            for a = 1:numel(in.alphas);
                gab.contrasts{a} = [0, logspace(log10(0.0001), log10(in.alphas(a)), nContrasts)];
            end
            
        case 'absthresh'
            
            % Most of these parameters don't matter b/c later I'll zero out
            % the entire stiulus except for a single pixel. The only thing
            % that doesn't get changed is the stimulus length. Also, the
            % contrast no longer signifies CC, and now signifies an integer
            % number of R* (to be delivered in a single time step)
            gab.sd = 1;           % in 1/10 dva
            gab.nSd = .2;         % number of SDs in gabor
            gab.theta = 0;        % in radians. Zero is horizontal drifting up
            gab.gamma = 1;        % SDx == SDy
            gab.sf = 1;           % in cpd
            gab.driftRate = 3;    % in cyc/sec
            gab.length = 0.400;   % in sec. should be same length as the filter
            gab.rf_x = 25;        % in 1/10 dva
            gab.rf_y = 25;        % in 1/10 dva
            gab.colorDirs = [1, 1, 1];
            gab.contrasts = {0:1:600}; % integer number of R*, NOT cone contrast!!!
            
    end
end

function movie = makeGaborMovie(LMS_Rstar, gab, mon, TYPE, params)
    
    % Define the constants
    nPix = round((gab.nSd*2) .* (gab.sd./10) .* mon.pixperdeg);
    halfSize = round(nPix./2);
    gaborPhase = 0;
    flashDeltaPhase = gab.driftRate * 2 * pi * (1./mon.frameRate); %the amount to advance each frame
    sigmaInPix = (gab.sd./10) .* mon.pixperdeg;
    lambdaInPix = 1./ (gab.sf ./ mon.pixperdeg);
    
    % Parameters for ramping on/off stimulus
    flashNumFrames = ceil(mon.frameRate * gab.length);
    rampLength = ceil(flashNumFrames / 4); %in frames
    ramp = linspace(0, 1, rampLength);  %ramp is 1/4th of the total duration on either side
    plateau = ones(1,flashNumFrames - (rampLength .* 2));
    flashTimeProf = [ramp, plateau, fliplr(ramp)];

    % meshgrid for the gabor
    row = -halfSize:halfSize-1; %subtract one so that you don't overlap the texture window;
    col = -halfSize:halfSize-1;
    [X, Y] = meshgrid(row, col);
    xprime = X .* cos(-gab.theta) + Y .* sin(-gab.theta);
    yprime = -X .* sin(-gab.theta) + Y .* cos(-gab.theta);
    

    % Preallocate space for the movie (4D: [X, Y, Time, Guns])
    movie = nan(size(X,1), size(X,1), flashNumFrames, 3);
    
    % This function can be used to make a stimulus movie, or a
    % spatiotemporal weighting function for ideal observer analysis, or a
    % simple stimulus for the absolute threshold expts.
    if strcmpi(TYPE, 'movie') && ~strcmpi(params.runType, 'absthresh') % the normal case, just making a gabor
            Rstar_increment = LMS_Rstar - mon.bkgndlms_Rstar;
            bkgnd_Rstar = mon.bkgndlms_Rstar;
    elseif strcmpi(TYPE, 'idlob template')
            bkgnd_Rstar = [0 0 0];
            Rstar_increment = LMS_Rstar; % should be 1, -1, or 0.
    elseif strcmpi(TYPE, 'movie') && strcmpi(params.runType, 'absthresh') % for absThresh expts
            movie(:) = 0;
            movie(1,1,1,1) = LMS_Rstar(1); % put an integer number of R* in the first pix, first time step, L cone map.
            return % nothing else to do...
    end
    
    
    % Make the movie frame by frame.
    for t = 1:flashNumFrames;

        % Multiply the gabor by the increment from background and by the temporal weighting fxn.
        gabor = exp(-(xprime.^2 + gab.gamma.^2 .* yprime.^2) ./ (2.* sigmaInPix.^2)) .* cos(2 .* pi .* yprime ./ lambdaInPix + gaborPhase);

        %R*/sec for each pix/frame/cone
        movie(:,:,t,1) = (gabor .* flashTimeProf(t) .* Rstar_increment(1)) + bkgnd_Rstar(1);
        movie(:,:,t,2) = (gabor .* flashTimeProf(t) .* Rstar_increment(2)) + bkgnd_Rstar(2);
        movie(:,:,t,3) = (gabor .* flashTimeProf(t) .* Rstar_increment(3)) + bkgnd_Rstar(3);

        % Update the phase
        gaborPhase = gaborPhase + flashDeltaPhase;
    end
end

function lms_Rstar = getGaborRstar(clr, cnt, gab, mon, params, cones)
    % this function will calculate the LMS_Rstar values for each
    % color/contrast combination. If the color dirs are specified as
    % strings, than assume the user wants gun iso colors
    
    if ischar(gab.colorDirs(clr,:));
        
        % gun iso specified as 'rgun', 'ggun', 'bgun' in the 'gab.colorDirs
        % field.
        switch gab.colorDirs(clr,:)
            case 'rgun'
                gunisodir = [1 0 0];
            case 'ggun'
                gunisodir = [0 1 0];
            case 'bgun'
                gunisodir = [0 0 1];
        end
        
        % change the gunisodir into LMS_Rstar.
        GC = gab.contrasts{clr}(cnt); % Gun Contrast
        gunDirContrast = gunisodir(:) .* GC;
        rgbTrial = mon.bkgndrgb(:) .* (gunDirContrast + 1);
        lms_Rstar = mon.rgb2Rstar * rgbTrial; % convert from gun intensity space to cone R* space
        
    elseif strcmpi(params.runType, 'absthresh')
        % in this case, the "contrast" array specifies an integer number of
        % photons...
        if cones.samplingRate ~= 1000 || mon.frameRate ~= 100;
            mon.frameRate
            cones.samplingRate
            error('Sampling rate or refresh rate not set appropriately')
        end
        pulseWidth = 0.010; %only works if refresh and cone sampling rates are set correctly
        RStarPerSec = gab.contrasts{clr}(cnt) ./ pulseWidth; %an integer number of photons delivered in one time step (expressed in R*/sec)
        lms_Rstar = [RStarPerSec; 0; 0] % only deliver the stimulus to the Lcone mosaic
    else
        colorDir = gab.colorDirs(clr,:);
        colorDir = colorDir ./ norm(colorDir); %make sure it's a unit vector
        CC = gab.contrasts{clr}(cnt); %cone contrast in vector norms
        LMS = colorDir .* CC;
        lms_Rstar = (1+LMS(:)) .* mon.bkgndlms_Rstar(:);
        
        % a simple error check on the cone sampling rate
        if ~any(softEq(cones.samplingRate, [525 600 675 750 825 900 975], 3))
            error('might have the incorrect cone sampling rate')
        end
    end

end

function mon = initMonitorCalibration(params, gab)

    % load in some information about the monitor.
    switch lower(params.runType)
        case {'default', 'dtnt', 'absthresh'}

            %load in calibration data from a representative file
            params.monCalFile
            load(params.monCalFile)
            
            % pacakge some other relavant info
            monSpect = reshape(cal.monSpect, [],3);
            mon.bkgndrgb = cal.bkgndrgb;
            mon.frameRate = cal.frameRate;
            mon.monSpectWavelengths = 380:5:780;
            mon.pixperdeg = cal.pixperdeg;
            
        case 'dtv1'
            DT = params.V1stro;
            monSpect = reshape(DT.sum.exptParams.mon_spect, [], 3);
            mon.bkgndrgb = [DT.sum.exptParams.bkgnd_r, DT.sum.exptParams.bkgnd_g, DT.sum.exptParams.bkgnd_b];
            mon.frameRate = DT.sum.exptParams.frame_rate;
            mon.monSpectWavelengths = 380:5:780;
            mon.pixperdeg = DT.sum.exptParams.pixperdeg;
    end
    
    %generate the cone action spectra using the wavelengths at which the
    %monitor was calibrated
    actionSpectra(1,:) = coneActionSpectra('LCone',mon.monSpectWavelengths);
    actionSpectra(2,:) = coneActionSpectra('MCone',mon.monSpectWavelengths);
    actionSpectra(3,:) = coneActionSpectra('SCone',mon.monSpectWavelengths);
    
    % do some pre-retinal filtering on the action spectra to generate the
    % "corneal cone fundamentals"
    fundamentals = preRetinalFiltering(actionSpectra);
    
    % the monitor spectra are in units of spectral radiance (W/(str*M^2)).
    % Convert these values to retinal irradiance in W/um^2.
    eyeSize = 20;   % in mm;
    pupilArea = 12.566;  % in mm^2... assuming a radius of 2mm which is pretty close to Freya's measurements (12.566)
    monitorIrradiance = retinalIrradiance(monSpect,pupilArea,eyeSize);
    
    % Adjust the irradiance values to reflect the macular pigment density
    monitorIrradiance = macularPigment(monitorIrradiance, gab, mon, params.unitTest);
    

    % adjust the Irradiance values so that they are in units of W/cone
    coneCollectingArea = 0.7; %in p(absorb)/um^2 (JA & CAH).. about 0.7
    monitorIrradiance = monitorIrradiance .* coneCollectingArea;
    
    %"monitorIrradiance" is in units of W/cone. Now convert to
    %photons/sec/cone. The energy of a photon is equal to:
    %
    % Energy of photon = hc/lambda
    %
    %where h = plank's constant, c = speed of light, lambda = wavelength
    %in meters.
    %
    %To convert to photons/s/cone we just divide the energy due to the
    %monitor by the energy in a single photon:
    %
    % photons = monitorIrradiance ./ (hc/lambda);
    hc = 6.626069e-34 .* 3e8; %Planck's constant * Speed of Light
    lambdas = repmat(mon.monSpectWavelengths', 1, 3) ./ 1e9; %converting to nm
    photonSpectra = monitorIrradiance ./ (hc./lambdas);
    
    % make a matrix that converts from gun (intensity) space to cone (R*/sec)
    % space:
    mon.rgb2Rstar = fundamentals * photonSpectra;
    
    % determine the R* due to the background intensity of the monitor
    mon.bkgndlms_Rstar = mon.rgb2Rstar * mon.bkgndrgb(:);
end

function cones = initConeMosaic_new(gab, mon)
    
    % start by calculating the visual angle subtended by a single pixel
    gaborWidth_dva = (gab.sd/10) .* (gab.nSd .* 2); 
    gaborWidth_pix = round(gaborWidth_dva .* mon.pixperdeg); %should be ~125 pix for a 2.4 dva stimulus
    pixWidth_dva= gaborWidth_dva ./ gaborWidth_pix;
    
    % use snell's law to determine the amount of retinal area illuminanted
    % by a single pixel. 
    %
    % Snell's law: sin(theta_hat) = (N/N_hat) * sin(theta)
    %
    % Where theta is the angle of incidence from the stimulus, N is the
    % refractive index outside the eye, N_hat is the index inside the eye,
    % and theta_hat is the angle of the light once refracted by the optics.
    %
    % For monkeys, N = 1, N_hat = 1.25. Thus:
    %
    % theta_hat = asind(0.75 * sind(theta) )
    %
    % For a reduced eye in which the posterior focal length (F_ret) is
    % about 18 mm for monkeys, I can solve for the retinal width (W_ret)
    % of a pixel by:
    %
    % tand(theta_hat) = W_ret / F_ret
    %
    % so, W_ret = tand(theta_hat) .* F_ret
    theta_hat = asind(0.75 .* sind(pixWidth_dva));
    W_ret = tand(theta_hat) .* 18; %W_ret will be in mm. be sure to use atand and not atan...
    pixRetinalArea_mm2 = W_ret^2;
    
    
    % now find the eccentricity of each of the pixel centers, and solve for
    % the cone density at each of these locations. then allocate the
    % correct number of cones to these locations based off the retinal area
    % of each pixel.
    gaborHalfWidth_dva = gaborWidth_dva ./ 2;
    center_x = gab.rf_x/10; %in dva
    center_y = gab.rf_y/10; %in dva
    pix_x = linspace(center_x-gaborHalfWidth_dva, center_x+gaborHalfWidth_dva, gaborWidth_pix*2+1);%finding half pixels
    pix_x = pix_x(2:2:end); %Pixel centers in dva;
    pix_y = linspace(center_y-gaborHalfWidth_dva, center_y+gaborHalfWidth_dva, gaborWidth_pix*2+1);%finding half pixels
    pix_y = pix_y(2:2:end); %Pixel centers in dva;
    
    %make a meshgrid to find each pixel's eccentricity
    [X, Y] = meshgrid(pix_x, pix_y);
    eccInDVA = sqrt(X.^2 + Y.^2);
    
    %Solving for cone density per pixel. Also taken from juan's ConeGrid function.
    coeffs=[150.9676 -1.2220 35.9979 -0.1567 9.9936 -0.0258]; % for macaque (Goodchild et al., 1996)
    coneDensity= (coeffs(1).*(exp(coeffs(2).*eccInDVA)))+...
        (coeffs(3).*(exp(coeffs(4).*eccInDVA)))+...
        (coeffs(5).*(exp(coeffs(6).*eccInDVA)));
    conesPerMM2=coneDensity*1e3; % in cones/mm^2 Left out in Goodchild et al., 1996? Compare to their Fig 5 & 7
    
    
    % number of cones per "pixel" on the retina
    conesPerPix_all = conesPerMM2 .* pixRetinalArea_mm2;
    
    % Solving for S-cone density per MM2. Taken from Monasterio 1985 (only
    % good b/w 2 and 60 dva.
    if any(eccInDVA(:)<2) || any(eccInDVA(:)>60)
        warning('Scone density not accurate outside of 2 to 60 dva!')
    end
    mmPerDeg = W_ret .* mon.pixperdeg;
    mmPerDeg = 0.200; % for comparison with the old version of the code.
    warning('Using a fixed mmPerDeg conversion factor');
    a = 121.86; % Solving for S-cone density (temporal side).
    b = -0.206;
    c = 89.95;
    d = -0.045;
    SconesPerDeg2 = (a.*exp(b.*eccInDVA)) + (c.*exp(d.*eccInDVA));
    SconesPerMM2 = SconesPerDeg2 ./ (mmPerDeg^2);
    conesPerPix_S = SconesPerMM2 .* pixRetinalArea_mm2;
    
    %assemble the outputs
    cones.num_S = conesPerPix_S;
    cones.num_L = (conesPerPix_all - conesPerPix_S) ./ 2;
    cones.num_M = (conesPerPix_all - conesPerPix_S) ./ 2;
    keyboard
    
end

function cones = initConeMosaic(gab, mon)

    %find the pixel centers (in dva)
    gaborWidthInPix = round((gab.sd/10) .* (gab.nSd .* 2) .* mon.pixperdeg); %should be ~125 pix
    if rem(gaborWidthInPix,2);
        gaborWidthInPix = gaborWidthInPix+1; % due to rounding, this should make thie dims of the mosaic the same as the dims of the gabor
    end
    gaborHalfWidthDVA = (gab.sd/10) .* gab.nSd;
    center_x = gab.rf_x/10; %in dva
    center_y = gab.rf_y/10; %in dva
    pix_x = linspace(center_x-gaborHalfWidthDVA, center_x+gaborHalfWidthDVA, gaborWidthInPix*2+1);%finding half pixels
    pix_x = pix_x(2:2:end); %Pixel centers in dva;
    pix_y = linspace(center_y-gaborHalfWidthDVA, center_y+gaborHalfWidthDVA, gaborWidthInPix*2+1);%finding half pixels
    pix_y = pix_y(2:2:end); %Pixel centers in dva;
    
    %make a meshgrid to find each pixel's eccentricity
    [X, Y] = meshgrid(pix_x, pix_y);
    eccInDVA = sqrt(X.^2 + Y.^2);
    
    %Solving for retinal area per pixel. Code taken from Juan's ConeGrid
    %function. Juan says that the function relating eccentricity to area is
    %a 2nd order polynomial (Goodchild et al., 1996)
    pixelWidth = ((gab.sd/10) .* gab.nSd .* 2) ./ gaborWidthInPix; %the width of a single pix in dva
    outer=(0.038.*(eccInDVA+pixelWidth./2).^2) + (4.21.*(eccInDVA+pixelWidth./2)) + 0.1;
    inner=(0.038.*(eccInDVA-pixelWidth./2).^2) + (4.21.*(eccInDVA-pixelWidth./2)) + 0.1;
    stimDiameter=(outer-inner); %in mm
    retinalArea=pi.*(stimDiameter./2).^2; %in mm^2/pix

    %Solving for cone density per pixel. Also taken from juan's ConeGrid function.
    coeffs=[150.9676 -1.2220 35.9979 -0.1567 9.9936 -0.0258]; % for macaque (Goodchild et al., 1996)
    coneDensity= (coeffs(1).*(exp(coeffs(2).*eccInDVA)))+...
        (coeffs(3).*(exp(coeffs(4).*eccInDVA)))+...
        (coeffs(5).*(exp(coeffs(6).*eccInDVA)));
    conesPerMM2=coneDensity*1e3; % in cones/mm^2 Left out in Goodchild et al., 1996? Compare to their Fig 5 & 7
    
    % Solving for S-cone density per MM2. Taken from Monasterio 1985 (only
    % good b/w 2 and 60 dva.
    if any(eccInDVA(:)<2) || any(eccInDVA(:)>60)
        warning('Scone density not accurate outside of 2 to 60 dva!')
    end
    mmPerDeg = 0.242; % using snell's law
    a = 121.86; % Solving for S-cone density (temporal side).
    b = -0.206;
    c = 89.95;
    d = -0.045;
    SconesPerDeg2 = (a.*exp(b.*eccInDVA)) + (c.*exp(d.*eccInDVA));
    SconesPerMM2 = SconesPerDeg2 ./ (mmPerDeg^2);
    
    %Find the total number of cones per pixel and then divide between L/M/S
    numCones_total = round(retinalArea .* conesPerMM2);
    numScones_total = round(retinalArea .* SconesPerMM2);
    percentScones = numScones_total ./ numCones_total;
    numCones_S = round(numCones_total .* percentScones); %the number of S-cones per pix... assuming 10% S-cones in the mosaic
    remainingCones = numCones_total - numCones_S;
    numCones_L = binornd(remainingCones, 0.5);
    numCones_M = numCones_total - numCones_S - numCones_L;
    
    %assemble the outputs
    cones.num_L = numCones_L;
    cones.num_M = numCones_M;
    cones.num_S = numCones_S;
    
    %check that the sum of L,M,S is the total number of cones expected
    if any((numCones_L(:) + numCones_M(:) + numCones_S(:)) ~= numCones_total(:))
        error('Did not get the predicted number of cones....')
    end
end

function cones = modifyConeMosaic(cones)
    % this function is used for the absolute threshold experiments. We want
    % to restrict our attention to only a few cones, so this function takes
    % the original cone mosaic and modifies it accordingly. This is a total
    % hack, but allows me to run the absThresh experiment on the existing
    % code...
    
    Ncones = 1; % the TOTAL number of cones to consider.
    [cones.num_L, cones.num_M, cones.num_S] = deal(zeros(size(cones.num_L))); % start by zeroing everything out.
    cones.num_L(1,1) = Ncones; % put all the cones in the same pix. To make life easy, just put it in 1st pix.
end

function [cones, gab] = makeConeLinearFilter(params, cones, mon, gab)
    %
    %Stealing code from juan to make the linear filter for the cones. I'll
    %export the filter in the fourier domain b/c this is the only version
    %that gets used in coneVolution.
    
    %figure out the cone "sampling rate"
    cones.samplingRate = 825; %desired rate in Hz. Good candidates: [525 600 675 750 825 900 975]
    cones.samplesPerFrame = round(cones.samplingRate./mon.frameRate);
    cones.samplingRate = cones.samplesPerFrame.*mon.frameRate; %adjusted due to rounding
    
    % determine how many samples the cone impulse response should contain.
    % Also determine how many samples to add to the beginning of the Gabor
    % to allow the simulation to attain steady state.
    gab.framesInNewGabor = ceil(mon.frameRate .* gab.length) .* cones.samplesPerFrame; %up sample due to the cone sampling rate
    filterTimeLength = 0.400; %seconds
    cones.filterSamples = ceil(filterTimeLength .* cones.samplingRate);
    cones.nFrontPad = cones.filterSamples+5; %add to the front of the gabor to allow the system to come to steady state
    cones.convLength = (cones.nFrontPad + gab.framesInNewGabor) + cones.filterSamples - 1; % conv gives length N+M-1
    cones.nBackPad = cones.convLength - (cones.nFrontPad + gab.framesInNewGabor); % add to the back of the gabor so that the dimensionality of the gabor stimulus is 1xConvLength
    
    %make the filter.
    switch params.impulseResponse
        case 'rieke'
            %Juan says the units are time (in sec) vs pA/R*/cone
            TimeAxis=[0:(cones.convLength-1)] ./ cones.samplingRate;
            ScFact = 0.6745;% coef(1);
            TauR = 0.0216; %Rising Phase Time Constant
            TauD = 0.0299; %Damping Time Constant
            TauP = 0.5311; %Period
            Phi = 34.1814; %Phase
            Filter = ScFact .* (((TimeAxis./TauR).^3)./(1+((TimeAxis./TauR).^3))) .* exp(-((TimeAxis./TauD))).*cos(((2.*pi.*TimeAxis)./TauP)+(2*pi*Phi/360));
        
        case 'deltafxn'
            % just make a "discrete" delta fxn
            Filter = zeros(1, cones.convLength);
            Filter(5) = cones.samplingRate;
    end
    
    
    % many of the samples in the filter are just there as place holders to
    % make the dimensionality consistent with the gabor (to facilitate FFT
    % convolution and mulitplication in the fourier domain). These values
    % should be close to zero, but set them explicitly to zero. Doing so
    % makes the FFT-conv identical to the real conv (see testing routines).
    Filter(cones.filterSamples+1:end) = 0;
    
    % convert to fourier domain
    cones.filter_fft = fft(Filter); %not normalizing here, but will compensate in coneVolution_FFT (below)
end

function cones = makeConePowerSpectrum(cones, gab)
    % Using Juan's code to generate cone noise based on the power spectrum
    % calculated from recordings of cone noise fit with a sum of 2
    % Lorentzians up to 1kHz.
    %
    % The values for the Lorentzians seem to come from the data file named
    % "022211Ec07". Juan says "check ConeNoisePSFittingWalkthrough" for
    % details about the fitting
    %
    % Angueyra  1/2010  Created the function
    % CAH       2/2012  Integrated the fxn into DTcones and changed how the
    %                   frequency axis is defined for odd and even N.
    %           9/2012  Switching to two-sided PS
    %

    % constants:
    lorentzCoeffs = [0.2, 30, 2.0, 0.05, 180, 2.5];
    samplingRate = cones.samplingRate; %in samp/sec

    % Calculate the frequncy axis
    N = gab.framesInNewGabor;
    if rem(N,2)
        k = -((N-1)./2):((N-1)./2); % pos freqs when N is Odd. For two sided freqs: k = -((N-1)./2):((N-1)./2)
    else
        k = -(N./2):((N./2)-1); % 0:(N./2) => abs(neg Freqs) when N is even. For two sided freqs: k = -(N./2):((N./2)-1)
    end
    freqAxis = (k./N).*samplingRate;

    % generate the positive portion of the PS
    l_posFreq = freqAxis>=0;
    tmpFreqs = freqAxis(l_posFreq);
    PS_posFreq = abs(lorentzCoeffs(1)) ./ (1 + (tmpFreqs ./ abs(lorentzCoeffs(2))).^2).^lorentzCoeffs(3);
    PS_posFreq = PS_posFreq + abs(lorentzCoeffs(4)) ./ (1 + (tmpFreqs ./ abs(lorentzCoeffs(5))).^lorentzCoeffs(6));

    % generate the negative portion of the PS by finding the PS at the
    % abs(negative freqs). This is b/c juan's model is only defined on the
    % positve interval
    l_negFreq = freqAxis<0;
    tmpFreqs = abs(freqAxis(l_negFreq));
    PS_negFreq = abs(lorentzCoeffs(1)) ./ (1 + (tmpFreqs ./ abs(lorentzCoeffs(2))).^2).^lorentzCoeffs(3);
    PS_negFreq = PS_negFreq + abs(lorentzCoeffs(4)) ./ (1 + (tmpFreqs ./ abs(lorentzCoeffs(5))).^lorentzCoeffs(6));

    % Put the neg and pos parts of the PS together. Divide by 2 so that
    % the units are for a two-sided PS. Multiply by delta Frequency so
    % that the units are in pow/bin... not pow/Hz.
    cones.modelNoise_ps = [PS_posFreq, PS_negFreq];
    cones.modelNoise_ps = cones.modelNoise_ps ./ 2;
    dF = unique(diff(freqAxis));
    dF = dF(1);
    cones.modelNoise_ps = cones.modelNoise_ps .* dF;

    % turn the power spectra into ordinary magnitudes.;
    cones.modelNoise_fft = sqrt(cones.modelNoise_ps); %I'm wondering if this line needs a factor of N in it b/c Juan normalizes the FFT pow spect due to distrete sampling...
    cones.freqAxis_fft = [freqAxis(freqAxis>=0) freqAxis(freqAxis<0)];
end

function [cones, gab] = coneVolution_FFT(gab, cones, mon, DEBUG)
    
    % front pad, back pad, and upsample the gabor movie.
    [cones.linresp, gab.movie] = upsampleAndBookend(gab.movie, cones, mon);
    
    if exist('DEBUG', 'var') && strcmpi(DEBUG, 'impulse_response')
        % make an impulse in the middle of the stimlus. (adding this here
        % b/c i need access to a stimulus in 'cone sampling time'
        cones.linresp(:,:,:,:) = 0;
        idx = round( cones.nFrontPad + round(gab.framesInNewGabor./2) );
        cones.linresp(:,:,idx,:) = cones.samplingRate;
    end
    
    %convert the gabor movie to the fourier domain. the gabor movie is now
    %contained in cones.linresp to allow for in-place operations.
    cones.linresp = fft(cones.linresp, [], 3); %run the FFT in the "time" dimension
    
    % multiply the gabor and the coneFilter in the fourier domain.
    cones.linresp = bsxfun(@times, permute(cones.filter_fft, [1,3,2]), cones.linresp);
    
    % convert back to the time domain and compensate for the sampling rate.
    % The impuseresponseFFT and the stimulusFFT have not been adjusted for
    % the sampling rate, so do it here:
    %
    % ifft(FFT(x)/rate .* FFT(y)/rate)*rate = ifft(FFT(x) .* FFT(y)) ./ rate
    %
    cones.linresp = ifft(cones.linresp, [], 3) ./ cones.samplingRate;
    
    % hack off the bookends
    tRange = (cones.nFrontPad+1) : (size(cones.linresp,3) - cones.nBackPad);
    cones.linresp = cones.linresp(:,:, tRange, :);
    
    % simple error checking
    if gab.framesInNewGabor ~= size(cones.linresp, 3); error(' #### Size Mismatch in ConeVolution'); end
end

function [linresp, gaborMovie] = upsampleAndBookend(gaborMovie, cones, mon)

    % start by allocating space to an array that will become the new gabor
    % movie. This array should have the proper number of "time" dimensions
    % to allow the system to come to steady state, to acomodate the cone
    % sampling rate, and to avoid circular convolution via the FFT method.
    dims = size(gaborMovie);
    tmp = nan(dims(1), dims(2), cones.convLength, dims(4)); %this will become the new gabor movie
    tmp(:, :, 1:cones.nFrontPad, 1) = mon.bkgndlms_Rstar(1);
    tmp(:, :, 1:cones.nFrontPad, 2) = mon.bkgndlms_Rstar(2);
    tmp(:, :, 1:cones.nFrontPad, 3) = mon.bkgndlms_Rstar(3);
    
    
    % fill in the gabor movie and upsample to the cone sampling rate
    idx = cones.nFrontPad+1;
    for a = 1:dims(3); % dims(3) = nFrames in old gabor
        frames = idx:(idx+cones.samplesPerFrame-1);
        tmp(:,:,frames,1) = repmat(gaborMovie(:,:,a,1), [1, 1, cones.samplesPerFrame]);
        tmp(:,:,frames,2) = repmat(gaborMovie(:,:,a,2), [1, 1, cones.samplesPerFrame]);
        tmp(:,:,frames,3) = repmat(gaborMovie(:,:,a,3), [1, 1, cones.samplesPerFrame]);
        
        % update the idx
        idx = idx+cones.samplesPerFrame;
    end
    
    
    % pad each timeseries on the back to avoid circular convolution. The
    % padding must be zeros!!!
    for i = 1:3
        tmp(:, :, idx:cones.convLength, i) = 0;
    end
    
    % assign the newmovie to "cones.linresp" so that the FFT convolution can
    % be done "in place". This aviods making two giant arrays...
    linresp = tmp;
    gaborMovie = []; %kill the variable to save RAM
end

function mon = getBkgndLinearResp(cones, mon)
    
    % generate a time series that is composed of the bkgndlms_Rstar
    bkgnd = repmat(mon.bkgndlms_Rstar, 1, numel(cones.filter_fft));
    bkgnd(:, end-cones.nBackPad:end) = 0; %the padding for circular convolution needs to be zeros...
    bkgnd_fft = fft(bkgnd,[],2);
    linresp = bsxfun(@times, cones.filter_fft, bkgnd_fft) ./ cones.samplingRate;
    linresp = ifft(linresp, [], 2);
    linresp = linresp(:, (cones.nFrontPad+1) : (cones.convLength-cones.nBackPad));
    mon.bkgndlms_pA = mean(linresp,2);
end

function cones = shapedConeNoise(cones, gab, DEBUGMODE)
       
    % FFT of gaussian noise.
    N = gab.framesInNewGabor;
    if N ~= size(cones.linresp, 3); error('size mismatch between noise length and length of linear response'); end
    noiseSigma = sqrt(sum(cones.modelNoise_ps));
    WN_fft = fft(normrnd(0,noiseSigma,size(cones.linresp)),[],3)./N;
    
    % Shaping White Noise by the PowerSpectrum of Cone Dark Noise
    tmp = permute(cones.modelNoise_fft, [1,3,2]); %so that samples go in the "time" dimension
    cones.noise = bsxfun(@times, tmp, WN_fft);
    
    % Convert back to time domain.
    cones.noise = ifft(cones.noise, [], 3).*N;

    % Normalize Noise to match original variance. Here are some thoughts
    % about the scale factor: 
    % Parseval's theorm for finite length time sequences, as quoted form
    % numerical recipes, "The integral of the one-sided PSD (per unit time)
    % over positve frequency is equal to the mean squared amplitude of the
    % time signal".
    scaleFactor = sqrt(sum(cones.modelNoise_ps) ./ var(cones.noise, 0, 3));
    cones.noise = bsxfun(@times, cones.noise, scaleFactor);
    
    % run some testing routines if need be. Typically DEBUGMODE is only
    % defined if this function is called by a testing subfunction
    if (nargin==3) && strcmpi(DEBUGMODE, 'unit_test')
        runTestSubFxn()
    end
 
    function runTestSubFxn
        
        %
        % COMPARE THE PREDICTED AND AVERAGE NOISE
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % fft of the noise alone.
        pow = abs(fft(cones.noise, [], 3)./N); % actually magnitudes
        pow = (pow.^2).*2; % now power
        pow = permute(pow, [3,1,2,4]);
        pow = reshape(pow, N, []); % time goes down the columns
        pow_avg = mean(pow, 2)';
        
        
        %plot the average power spectra of the "shaped white noise"
        figure, hold on,
        plot(cones.freqAxis_fft(cones.freqAxis_fft>=0), pow_avg(cones.freqAxis_fft>=0), '-k', 'linewidth', 7)
        plot(cones.freqAxis_fft(cones.freqAxis_fft>=0), 2.*cones.modelNoise_ps(cones.freqAxis_fft>=0), 'r-', 'linewidth', 3)
        set(gca, 'yscale', 'log', 'xscale', 'log')
        xlabel('Frequency')
        ylabel('Power per Hz')
        legend('Average noise', 'Model noise')
        drawnow
        
        %
        % MAKE SURE THAT THE AVERAGE POWER SPECT OF WN IS ROUGHLY FLAT
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        tmp = permute(WN_fft, [3,1,2,4]);
        tmp = reshape(tmp, N, []); %time goes down the columns
        tmp = abs(fft(tmp,[],1));
        tmp = tmp.^2;
        tmp = mean(tmp,2);
        figure
        set(gcf, 'name', 'Average Powerspectra for White Noise');
        plot(cones.freqAxis_fft(cones.freqAxis_fft>=0), tmp(cones.freqAxis_fft>=0), '-k', 'linewidth', 2)
        ylim([0, max(tmp).*1.4])
        drawnow
        
        %
        % EXAMPLE AUTOCORRELATION FUNCTIONS
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        nRows = 5;
        pixels = [unidrnd(size(cones.noise,1), nRows^2,1), unidrnd(size(cones.noise,2), nRows^2,1), unidrnd(size(cones.noise,4), nRows^2,1)];
        
        
        figure
        set(gcf, 'position', [148 5 1184 824])
        set(gcf, 'name', 'Auto-correlation of shaped and unshape noise');
        for a = 1:size(pixels,1)
            tmp = permute(cones.noise(pixels(a,1), pixels(a,2), :, pixels(a,3)), [1,3,2,4]);
            [AC_shaped, lags_shaped] = xcorr(tmp, N./2, 'coeff');
            tmp = ifft(permute(WN_fft(pixels(a,1), pixels(a,2), :, pixels(a,3)), [1,3,2,4]));
            [AC_WN, lags_WN] = xcorr(tmp, N./2, 'coeff');
            
            subplot(nRows, nRows, a), hold on
            plot(lags_WN, AC_WN, 'r');
            plot(lags_shaped, AC_shaped, 'k', 'linewidth', 2);
            title(sprintf('[%d, %d, :, %d]', pixels(a,1), pixels(a,2), pixels(a,3)));
            axis tight
        end
        drawnow
        
        %
        % PRINT OUT SOME STATISTICS REGARDING THE SHAPED NOISE
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        %ttests for shaped noise
        tmp = permute(cones.noise, [3,1,2,4]);
        tmp = reshape(tmp, N,[]);
        [~,p_shaped] = ttest(tmp);
        
        %ttest for WN
        tmp = ifft(WN_fft,[],3);
        tmp = permute(tmp, [3,1,2,4]);
        tmp = reshape(tmp, N,[]);
        [~,p_WN] = ttest(tmp);
        
        %descriptive stats
        noiseVar = var(cones.noise, 0, 3);
        noiseVar = mean(noiseVar(:));
        noiseMean = mean(cones.noise,3);
        noiseMean = mean(noiseMean(:));
        
        %print the results to the command window
        fprintf('  Some statistics regarding the shaped noise: \n')
        fprintf('  1) Parseval''s theorem assumes zero mean: \n')
        fprintf('     Mean noise is %g pA \n', noiseMean);
        fprintf('     T-tests on shaped noise: p(type I error) = %.3f\n', sum(p_shaped<0.05)./numel(p_shaped));
        fprintf('     T-tests on white noise: p(type I error) = %.3f\n', sum(p_WN<0.05)./numel(p_WN));
        fprintf('  2) Variance of noise is %g pA^2 \n', noiseVar);
        
    end
end

function Spectrum=coneActionSpectra(Type,Wavelength)
    %
    % Spectrum=coneActionSpectra(Type,Wavelength)
    %
    % Type options: 'LCone','MCone','SCone','Rod'
    %
    % Generates Normalized Photoreceptor Spectral Sensitivity Curve relying on
    % fits derived from Baylor's et al. suction recordings (1985, 1987) on
    % macaque photoreceptors and fitted according to the Govadorvskii nomogram
    % (2000). Fitting procedure can be checked in FittingGovadorvskii.m
    %
    % Dec_2010 (Angueyra) Created the function.
    % Jan 2012 (CAH) Incorporated Juan's code into this script under the name coneActionSpectra

    switch Type
        case 'LCone'
            %values derived from fitting procedure
            LambdaMax=565.2836;
            BetaBandScaling=0.1460;
            Spectrum=GovadorvskiiTemplateA1([LambdaMax,BetaBandScaling],Wavelength);
        case 'MCone'
            %values derived from fitting procedure
            LambdaMax=534.3201;
            BetaBandScaling=0.1797;
            Spectrum=GovadorvskiiTemplateA1([LambdaMax,BetaBandScaling],Wavelength);        
        case 'SCone'
            %values derived from fitting procedure
            LambdaMax=430.4053;
            BetaBandScaling=0.5210;
            Spectrum=GovadorvskiiTemplateA1([LambdaMax,BetaBandScaling],Wavelength);  
        case 'Rod'
            %values derived from fitting procedure
            LambdaMax=493.3022;
            BetaBandScaling=0.1233;
            Spectrum=GovadorvskiiTemplateA1([LambdaMax,BetaBandScaling],Wavelength);
    end
end

function fit = GovadorvskiiTemplateA1(beta, wavelength)

    % Govadorvskii template for A1-based pigments with alpha nad beta band
    % Based on Govadorvskii et al., 2000
    %
    % Dec 2010 (Angueyra) Created the code
    % Jan 2012 (CAH) Pasted the code into this script without modification

    A=69.7;
    a=0.88;
    B=28.0;
    b=0.922;
    C=-14.9;
    c=1.104;
    D=0.674;

    alphafit=1./(exp(A.*(a-(beta(1)./wavelength)))+exp(B.*(b-(beta(1)./wavelength)))+exp(C.*(c-(beta(1)./wavelength)))+D);


    lambdaMaxBeta=189+0.315*beta(1);
    b=-40.5+0.195*beta(1); %bandwidth
    betafit=beta(2)*exp(-(((wavelength-lambdaMaxBeta)./b).^2));

    fit=alphafit+betafit;
end

function irradiance = retinalIrradiance(radiance,pupilAreaMM,eyeSizeMM)
    %
    % Perform the geometric calculations necessary to convert a measurement of source
    % radiance to corresponding retinal irradiance. 
    %
    %   Input radiance should be in units of power/m^2-sr-wlinterval.
    %   Input pupilAreaMM should be in units of mm^2.
    %   Input eyeSizeMM should be the length of the eye in mm.
    %   Output irradiance is in units of power/um^2-sec-wlinterval.
    %
    % Jan 2012 (CAH) Stealing code from David Brainard. See ptb's function
    %                "RadianceToRetIrradiance" for more details.
    
    % Convert power/sr-M^2-wlinterval to power/sr-mm^2-wlinterval
    radianceMM = radiance.*1e-6;
    
    % There are 4pi steradians per Surface Area of a sphere.
    % Since SA = 4*pi*r^2, 1 stradian = r^2. If the eye is circumscribed by
    % a hemisphere, than the number of steradians that the pupil covers is
    % simply the pupilArea/(eyeDiam^2);
    steradian = eyeSizeMM^2; %in mm^2
    nSteradians = pupilAreaMM/steradian;
    irradianceMM = radianceMM .* nSteradians;

    % Convert units to um^2 from mm^2 base.
    irradiance = irradianceMM.*1e-6;
end

function fundamentals = preRetinalFiltering(actionSpectra, DEBUGMODE)
    
    % define how the lens density should be manipulated
    METHOD = 'horwitz'; % 'Horwitz' for Gregs estimates based on monkey psychophysics, or 'SMJ' for the typical human measurements
    
    %load in the lens density measurements
    lensDensity_smj
    
    switch lower(METHOD)
        case 'horwitz'
            %make the lens density at 400nm equal to one. Arbitrary, but
            %results in good fits to the monkey psychophysics
            idx = find(S_lens_smj == 400);
            newDensity = den_lens_smj./den_lens_smj(idx);
            lenstransmittance = 1./(10.^(newDensity));
        case 'smj'
            % divide the lens density measurements by 1.16 to convert to
            % "open pupil", and multiply by 1.28 as per SMJ 1993
            scaleFactor = 1.28 ./ 1.16;
            newDensity = den_lens_smj .* scaleFactor;
            lenstransmittance = 1./(10.^(newDensity));
    end
        
    %define the optical density (humors + cornea + scatter). There is poor agreement on this value
    opticaldensity = 0.3; % From SMJ (1993) and other papers.
    
    %derive the corneal cone fundamentals by applying the transmittance
    %function to the Baylor action spectra. Notice that I'm not
    %incorporating macular pigment...
    lenstransmittance = lenstransmittance';
    fundamentals = 1 - 10.^(-actionSpectra .* opticaldensity);
    fundamentals = bsxfun(@times, fundamentals, lenstransmittance);
    fundamentals = bsxfun(@rdivide, fundamentals, max(fundamentals,[],2));
    
    
    if (nargin == 2) && strcmpi('unit_test', DEBUGMODE)
        figure,
        set(gcf, 'position', [8 297 1433 532])
        subplot(1,2,1), hold on,
        set(gca, 'fontsize', 14)
        plot(S_lens_smj, den_lens_smj, '-')
        plot(S_lens_smj, newDensity, '--')
        xlabel('Wavelength')
        ylabel('Density')
        legend('From SMJ', 'New Density')
        title(sprintf('Adjustment Method: %s', METHOD))
        
        subplot(1,2,2), hold on,
        load T_cones_smj10
        set(gca, 'fontsize', 14)
        plot(S_lens_smj, fundamentals')
        plot(S_lens_smj, T_cones_smj10', ':')
        plot(S_lens_smj, actionSpectra', '--')
        xlabel('Wavelength')
        ylabel('Normalized Response')
        legend('(-) Derived', '(:) SMJ 10', '(--) Action Spectra')
        ylim([0, 1.03])
        drawnow
    end
end

function newIrradiance = macularPigment(oldIrradiance, gab, mon, UNITTEST)
    
    % calculate the gabor's eccentricity
    gaborEccentricity = sqrt((gab.rf_x./10)^2 + (gab.rf_y./10)^2);
    if UNITTEST; gaborEccentricity = 1; end
    
    
    % determine the pigment density according to published data in humans
    % (Wooten 2005) with modifications for lower density in monkeys.
    macpigDensity = 0.33 .* exp(-gaborEccentricity./1.03); % from Wooten 2005
    
    % load in the macular pigment absorbance spectra. Scale the absorbance
    % to reflect the macular pigment density at the gabor eccentricity.
    % Next, convert to tranmittance.
    load 'den_mac_ws' % measured at the same wavelengths as the monitor...
    macpig_wf = S_mac_ws(1):S_mac_ws(2):(S_mac_ws(1)+S_mac_ws(2)*S_mac_ws(3)-1);
    if ~all(macpig_wf == mon.monSpectWavelengths); error('Mac pig wavelengths mismatch'); end;
    idx_460 = macpig_wf == 460;
    macpigAbsorbance = den_mac_ws ./ den_mac_ws(idx_460); % normalized to height = 1 at 460 nm
    macpigAbsorbance = macpigAbsorbance .* macpigDensity; % set's the absorbance at 460 nm according to the gabor eccentricity
    macpigTransmittance = 1./(10.^macpigAbsorbance); % transmittance is the reciprocal of absorbance
    
    % modify the monitor irradiance to reflect the macular pigment
    newIrradiance = bsxfun(@times, oldIrradiance, macpigTransmittance);
    
    if UNITTEST
        figure, hold on,
        plot(mon.monSpectWavelengths, oldIrradiance, '--');
        plot(mon.monSpectWavelengths, newIrradiance, '-');
        xlabel('Wavelength (nm)')
        ylabel('Irradiance')
        title(sprintf('Monitor irradiance for macpig at %.2f dva', gaborEccentricity));
        legend('without macpig')
    end
    
end

function idlob = initIdealObserver(observerMethod, gab)
    
    fxnHandle = str2func(observerMethod);
    idlob.method = fxnHandle;
    idlob = feval(fxnHandle, 'initialize', idlob, gab); %sets up the 'resp' field of the structure
    
end

function [idlob, cones] = obsMethod_rms(command, idlob, gab, cones, mon, clr, cnt, trl, params)
    
    switch lower(command)    
        case 'initialize'
            nColors = size(gab.colorDirs,1);
            nContrasts = size(gab.contrasts{1},2);
            nCones = 3;
            nTrials = gab.nTrials;
            
            %dimensionality will be (nColors x nCones x nContrasts x nTrials)
            [idlob.resp] = deal(nan(nColors, nCones, nContrasts, nTrials));
            
        case 'compute'
            
            % subtract off the mean from the linear response
            cones.linresp = bsxfun(@minus, cones.linresp, permute(mon.bkgndlms_pA, [3, 2, 4, 1])); %make the linear response zero mean.
            
            %generate the pooled response.
            sigPlusNoise = pooledRespose_average(cones);
            
            % now compute the ideal observer's response 
            N = numel(cones.num_L); % i.e., the number of pixels
            rms = sqrt(mean((sigPlusNoise.^2), 3)); %rms for each pixel/cone through time
            rms = squeeze(rms); %remove the "time" dimension
            idlob.resp(clr,1,cnt,trl) = sum(sum(rms(:,:,1)))./N;
            idlob.resp(clr,2,cnt,trl) = sum(sum(rms(:,:,2)))./N;
            idlob.resp(clr,3,cnt,trl) = sum(sum(rms(:,:,3)))./N;
    end
end

function [idlob, cones] = obsMethod_all(command, idlob, gab, cones, mon, clr, cnt, trl, params)
    
    switch lower(command)    
        case 'initialize'
            nColors = size(gab.colorDirs,1);
            nContrasts = size(gab.contrasts{1},2);
            nTrials = gab.nTrials;
            
            % dimensionality will be (nColors x nContrasts x nTrials)
            [idlob.resp] = deal(nan(nColors, nContrasts, nTrials));
            [idlob.analyticMean, idlob.analyticVar] = deal(nan(nColors, nContrasts));
            
        case 'compute'
            % subtract off the mean from the linear response
            zeroMeanLinResp = bsxfun(@minus, cones.linresp, permute(mon.bkgndlms_pA, [3, 2, 4, 1])); %make the linear response zero mean.
            
            % generate the pooled response and add the (pooled) noise.
            sigPlusNoise = zeroMeanLinResp + pooledNoise_average(cones);
            zeroMeanLinResp = []; %kill to save ram
            
            % weight the sigPlusNoise by a template based on the gabor
            % stimulus. The template will have the same phase relationship
            % as the real stimulus (for each cone type) but will peak at
            % +/- 1 instead of the peak Rstar.
            wt = makeGaborMovie(sign(gab.colorDirs(clr,:)), gab, mon, 'idlob template', params);
            [wt, ~] = upsampleAndBookend(wt, cones, mon);
            tRange = (cones.nFrontPad+1) : (size(wt,3) - cones.nBackPad);
            wt = wt(:,:, tRange, :); %hack off the bookends.
            dotWithLinResp = sum(sigPlusNoise .* wt, 3); %sum across the 'time' dimension
            idealObsResp = sum(sum(dotWithLinResp,1),2); %sum across the spatial dimensions.
            idealObsResp = squeeze(idealObsResp);
            
            % Give the ideal observer access to the color direction:
            wt = gab.colorDirs(clr,:) ./ norm(gab.colorDirs(clr,:));
            wt = abs(wt);
            idlob.resp(clr, cnt, trl) = wt * idealObsResp;
            %idlob.resp(clr, cnt, trl) = sum(idealObsResp);
            
        case 'analytic_solution'
            % compute the mean and variance independently. This will mean
            % incorporating the wt fxns seperately for the mean and variance.
            
            % (1) make a spatiotemporal wt fxn. The template will have
            % the same phase relationship as the real stimulus (for each
            % cone type) but will peak at +/- 1 instead of the peak Rstar.
            wt_spaceTime = makeGaborMovie(sign(gab.colorDirs(clr,:)), gab, mon, 'idlob template', params);
            [wt_spaceTime, ~] = upsampleAndBookend(wt_spaceTime, cones, mon);
            tRange = (cones.nFrontPad+1) : (size(wt_spaceTime,3) - cones.nBackPad);
            wt_spaceTime = wt_spaceTime(:,:, tRange, :); %hack off the bookends.
            
            % (2) make a color direction wt fxn
            wt_clr = gab.colorDirs(clr,:) ./ norm(gab.colorDirs(clr,:));
            wt_clr = abs(wt_clr);
            
            % (4) combine the weighting functions.
            wt_spaceTimeColor = bsxfun(@times, wt_spaceTime, permute(wt_clr, [4,3,1,2]));
            
            % (5) calculate the mean response of the ideal observer
            idlOb_mean = bsxfun(@minus, cones.linresp, permute(mon.bkgndlms_pA, [3, 2, 4, 1])); %make the linear response zero mean.
            idlOb_mean = idlOb_mean .* wt_spaceTimeColor;
            idlob.analyticMean(clr, cnt) = sum(idlOb_mean(:)); %sum across space, time, and cone type;
            
            % (6) calculate the variance of the ideal observer. This
            % should be the same for each contrast (within color
            % directions) but for now I'm calculating it for each condition
            wt_spaceTimeColor_FFT = fft(wt_spaceTimeColor,[],3); % NOT NORMALIZING, and so I don't the the .* N^2 later...
            noise_fft = bsxfun(@times, wt_spaceTimeColor_FFT, permute(cones.modelNoise_fft, [1,3,2])); % weighting by the space/time/clr fxn in the fft domain
            noise_fft = sum(abs(noise_fft).^2, 3); % variance of a single pixel across time
            noise_fft = squeeze(noise_fft); % remove the (singelton) time dimension 
            numCones = cat(3, cones.num_L, cones.num_M, cones.num_S);
            noise_fft = noise_fft ./ numCones; % the noise is independent from cone to cone (within pixels) so the average var = var(x)/numCones
            idlob.analyticVar(clr, cnt) = sum(noise_fft(:)); % ideal observer sums signals from adjecent pix, so variances add.
            
        case 'equate_mosaic'
            
            % For cone isolating stimuli, the ideal observer should produce
            % the identical responses if the cone mosaics are ths same.
            cones.num_M = cones.num_L;
            cones.num_S = cones.num_L;
    end
end

function [idlob, cones] = obsMethod_noClrEqSpace(command, idlob, gab, cones, mon, clr, cnt, trl, params)
    %
    % This ideal observer only has access to the spatiotemporal weighting
    % function. Also, the space/time wt function is a gabor stimulus that
    % peaks/troughs at 1. All the cones in the wt fxn are in phase with
    % eachother. The result is a 3 vector for each trial. I'll have to do
    % linear discriminant inorder to determine the neurometric threshold.
    
    switch lower(command)    
        case 'initialize'
            nColors = size(gab.colorDirs,1);
            nContrasts = size(gab.contrasts{1},2);
            nTrials = gab.nTrials;
            
            % dimensionality will be (nColors x nContrasts x nTrials) for
            % the monte carlo method, and (nColors x nContrasts) for the
            % analytic solution. Each entry will be a CELL ARRAY of three
            % numbers, one for each cone type. I'm doing this so that the
            % arrays have the same dimensionality as obsMethod_all and so I
            % can use the same offline analysis scripts.
            [idlob.resp(1:nColors, 1:nContrasts, 1:nTrials)] = deal({nan(1,3)});
            [idlob.analyticMean(1:nColors, 1:nContrasts), idlob.analyticVar(1:nColors, 1:nContrasts)] = deal({nan(1,3)});
            
        case 'compute'
            % subtract off the mean from the linear response
            zeroMeanLinResp = bsxfun(@minus, cones.linresp, permute(mon.bkgndlms_pA, [3, 2, 4, 1])); %make the linear response zero mean.
            
            % generate the pooled response and add the (pooled) noise.
            sigPlusNoise = zeroMeanLinResp + pooledNoise_average(cones);
            clear zeroMeanLinResp %kill to save ram
            
            % weight the sigPlusNoise by a template based on the gabor
            % stimulus. The template will peak at +/- 1 instead
            % of the peak Rstar. The template cone mosaics are all IN PHASE
            % despite the fact that the stimulus may not be.
            wt = makeGaborMovie([1,1,1], gab, mon, 'idlob template', params); % use [1,1,1] to make the SAME template for all color directions in the simulation
            [wt, ~] = upsampleAndBookend(wt, cones, mon);
            tRange = (cones.nFrontPad+1) : (size(wt,3) - cones.nBackPad);
            wt = wt(:,:, tRange, :); %hack off the bookends.
            dotWithLinResp = sum(sigPlusNoise .* wt, 3); %sum across the 'time' dimension
            idealObsResp = sum(sum(dotWithLinResp,1),2); %sum across the spatial dimensions.
            idlob.resp{clr, cnt, trl} = squeeze(idealObsResp);
            
        case 'analytic_solution'
            % compute the mean and variance independently. This will mean
            % incorporating the wt fxns seperately for the mean and variance.
            
            % (1) make a spatiotemporal wt fxn. The template will peak at
            % +/- 1 instead of the peak Rstar.
            wt_spaceTime = makeGaborMovie([1,1,1], gab, mon, 'idlob template', params);
            
%             % Un-comment these lines to remove S-cones from the simulation
%             wt_spaceTime = makeGaborMovie([1,1,0], gab, mon, 'idlob template', params);
%             warning('Setting the output of the S-cone mosaic to zero')
            
            
            [wt_spaceTime, ~] = upsampleAndBookend(wt_spaceTime, cones, mon);
            tRange = (cones.nFrontPad+1) : (size(wt_spaceTime,3) - cones.nBackPad);
            wt_spaceTime = wt_spaceTime(:,:, tRange, :); %hack off the bookends.
            
            % (2) calculate the mean response of the ideal observer
            idlOb_mean = bsxfun(@minus, cones.linresp, permute(mon.bkgndlms_pA, [3, 2, 4, 1])); %make the linear response zero mean.
            idlOb_mean = idlOb_mean .* wt_spaceTime;
            idlOb_mean = sum(sum(sum(idlOb_mean,1),2),3); %sum across space. The sum over time is actually part of the dot product with the wt. fxn...
            idlob.analyticMean{clr, cnt} = squeeze(idlOb_mean);
            
            % (3) calculate the variance of the ideal observer. This
            % should be the same for each contrast (within color
            % directions) but for now I'm calculating it for each condition
            wt_spaceTime_FFT = fft(wt_spaceTime,[],3); % NOT NORMALIZING, and so I don't need the .* N^2 later...
            noise_fft = bsxfun(@times, wt_spaceTime_FFT, permute(cones.modelNoise_fft, [1,3,2])); % weighting by the space/time/clr fxn in the fft domain
            noise_fft = sum(abs(noise_fft).^2, 3); % variance of a single pixel across time
            noise_fft = squeeze(noise_fft); % remove the (singelton) time dimension 
            numCones = cat(3, cones.num_L, cones.num_M, cones.num_S);
            noise_fft = noise_fft ./ numCones; % the noise is independent from cone to cone (within pixels) so the average var = var(x)/numCones
            noise_fft = sum(sum(noise_fft,1),2); % ideal observer sums signals from adjecent pix, so variances add.
            idlob.analyticVar{clr, cnt} = squeeze(noise_fft);
            
        case 'equate_mosaic'
            
            % For cone isolating stimuli, the ideal observer should produce
            % the identical responses if the cone mosaics are ths same. Use
            % this functionality to run some debugging code.
            cones.num_M = cones.num_L;
            cones.num_S = cones.num_L;
    end
end

function [idlob, cones] = obsMethod_noClrEqSpaceAvgAllCones(command, idlob, gab, cones, mon, clr, cnt, trl, params)
    %
    % This ideal observer only has access to the spatiotemporal weighting
    % function. Also, the space/time wt function is a gabor stimulus that
    % peaks/troughs at 1. All the cones in the wt fxn are in phase with
    % eachother. The result is a 3 vector for each trial. I'll have to do
    % linear discriminant inorder to determine the neurometric threshold.
    
    switch lower(command)    
        case 'initialize'
            nColors = size(gab.colorDirs,1);
            nContrasts = size(gab.contrasts{1},2);
            nTrials = gab.nTrials;
            
            % dimensionality will be (nColors x nContrasts x nTrials) for
            % the monte carlo method, and (nColors x nContrasts) for the
            % analytic solution. Each entry will be a CELL ARRAY of three
            % numbers, one for each cone type. I'm doing this so that the
            % arrays have the same dimensionality as obsMethod_all and so I
            % can use the same offline analysis scripts.
            [idlob.resp(1:nColors, 1:nContrasts, 1:nTrials)] = deal({nan(1,3)});
            [idlob.analyticMean(1:nColors, 1:nContrasts), idlob.analyticVar(1:nColors, 1:nContrasts)] = deal({nan(1,3)});
            
        case 'compute'
            % subtract off the mean from the linear response
            zeroMeanLinResp = bsxfun(@minus, cones.linresp, permute(mon.bkgndlms_pA, [3, 2, 4, 1])); %make the linear response zero mean.
            
            % generate the pooled response and add the (pooled) noise.
            sigPlusNoise = zeroMeanLinResp + pooledNoise_average(cones);
            clear zeroMeanLinResp %kill to save ram
            
            % weight the sigPlusNoise by a template based on the gabor
            % stimulus. The template will peak at +/- 1 instead
            % of the peak Rstar. The template cone mosaics are all IN PHASE
            % despite the fact that the stimulus may not be.
            wt = makeGaborMovie([1,1,1], gab, mon, 'idlob template', params); % use [1,1,1] to make the SAME template for all color directions in the simulation
            [wt, ~] = upsampleAndBookend(wt, cones, mon);
            tRange = (cones.nFrontPad+1) : (size(wt,3) - cones.nBackPad);
            wt = wt(:,:, tRange, :); %hack off the bookends.
            dotWithLinResp = sum(sigPlusNoise .* wt, 3); %sum across the 'time' dimension
            idealObsResp = sum(sum(dotWithLinResp,1),2); %sum across the spatial dimensions.
            idlob.resp{clr, cnt, trl} = squeeze(idealObsResp);
            
        case 'analytic_solution'
            % compute the mean and variance independently. This will mean
            % incorporating the wt fxns seperately for the mean and variance.
            
            % (1) make a spatiotemporal wt fxn. The template will peak at
            % +/- 1 instead of the peak Rstar.
            wt_spaceTime = makeGaborMovie([1,1,1], gab, mon, 'idlob template', params);
            
%             % Un-comment these lines to remove S-cones from the simulation
%             wt_spaceTime = makeGaborMovie([1,1,0], gab, mon, 'idlob template', params);
%             warning('Setting the output of the S-cone mosaic to zero')
            
            
            [wt_spaceTime, ~] = upsampleAndBookend(wt_spaceTime, cones, mon);
            tRange = (cones.nFrontPad+1) : (size(wt_spaceTime,3) - cones.nBackPad);
            wt_spaceTime = wt_spaceTime(:,:, tRange, :); %hack off the bookends.
            
            % (2) calculate the mean response of the ideal observer
            idlOb_mean = bsxfun(@minus, cones.linresp, permute(mon.bkgndlms_pA, [3, 2, 4, 1])); %make the linear response zero mean.
            idlOb_mean = idlOb_mean .* wt_spaceTime;
            idlOb_mean = sum(sum(sum(idlOb_mean,1),2),3); %sum across space. The sum over time is actually part of the dot product with the wt. fxn...
            idlob.analyticMean{clr, cnt} = squeeze(idlOb_mean);
            
            % (3) calculate the variance of the ideal observer. This
            % should be the same for each contrast (within color
            % directions) but for now I'm calculating it for each condition
            wt_spaceTime_FFT = fft(wt_spaceTime,[],3); % NOT NORMALIZING, and so I don't need the .* N^2 later...
            noise_fft = bsxfun(@times, wt_spaceTime_FFT, permute(cones.modelNoise_fft, [1,3,2])); % weighting by the space/time/clr fxn in the fft domain
            noise_fft = sum(abs(noise_fft).^2, 3); % variance of a single pixel across time
            noise_fft = squeeze(noise_fft); % remove the (singelton) time dimension 
           
            % average the noise across all cones of the same type
            numCones = cat(3, cones.num_L, cones.num_M, cones.num_S);
            noise_fft = noise_fft .* numCones;
            noise_fft = sum(sum(noise_fft,1),2); % the sum of the scaled noise across space, for each cone type
            noise_fft = squeeze(noise_fft);
            numCones = sum(sum(numCones,1),2); % the total number of each cone type across space.
            numCones = squeeze(numCones); % remove the singelton space dimensions.
            idlob.analyticVar{clr, cnt} = noise_fft ./ numCones.^2;
            
        case 'equate_mosaic'
            
            % For cone isolating stimuli, the ideal observer should produce
            % the identical responses if the cone mosaics are ths same. Use
            % this functionality to run some debugging code.
            cones.num_M = cones.num_L;
            cones.num_S = cones.num_L;
    end
end

function [idlob, cones] = obsMethod_absThresh(command, idlob, gab, cones, mon, clr, cnt, trl, params)
    %
    % This ideal observer only has access to the spatiotemporal weighting
    % function. Also, the space/time wt function is a gabor stimulus that
    % peaks/troughs at 1. All the cones in the wt fxn are in phase with
    % eachother. The result is a 3 vector for each trial. I'll have to do
    % linear discriminant inorder to determine the neurometric threshold.
    
    switch lower(command)    
        case 'initialize'
            nColors = size(gab.colorDirs,1);
            nContrasts = size(gab.contrasts{1},2);
            nTrials = gab.nTrials;
            
            % dimensionality will be (nColors x nContrasts x nTrials) for
            % the monte carlo method, and (nColors x nContrasts) for the
            % analytic solution. 
            [idlob.resp] = deal(nan(nColors, nContrasts, nTrials));
            [idlob.analyticMean, idlob.analyticVar] = deal(nan(nColors, nContrasts));
            
        case 'compute'
            % subtract off the mean from the linear response
            zeroMeanLinResp = bsxfun(@minus, cones.linresp, permute(mon.bkgndlms_pA, [3, 2, 4, 1])); %make the linear response zero mean.
            
            % generate the pooled response and add the (pooled) noise.
            sigPlusNoise = zeroMeanLinResp + pooledNoise_average(cones);
            clear zeroMeanLinResp %kill to save ram
            
            % weight the sigPlusNoise by a template based on the gabor
            % stimulus. The template will peak at +/- 1 instead
            % of the peak Rstar. The template cone mosaics are all IN PHASE
            % despite the fact that the stimulus may not be.
            IRF = ifft(cones.filter_fft);
            IRF = IRF ./ max(IRF);
            IRF = IRF(1:cones.filterSamples);
            wt = makeGaborMovie([1,1,1], gab, mon, 'idlob template', params); % use [1,1,1] to make the SAME template for all color directions in the simulation
            [wt, ~] = upsampleAndBookend(wt, cones, mon);
            tRange = (cones.nFrontPad+1) : (size(wt,3) - cones.nBackPad);
            wt = wt(:,:, tRange, :); %hack off the bookends.
            wt(:) = 0; % for absThresh, turn all the values to zero.
            wt(1,1,:,1) = permute(IRF, [2, 4, 1, 3]);  
            
            dotWithLinResp = sum(sigPlusNoise .* wt, 3); %sum across the 'time' dimension
            idealObsResp = sum(sum(dotWithLinResp,1),2); %sum across the spatial dimensions.
            idlob.resp(clr, cnt, trl) = idealObsResp(1,1,1,1);
            
        case 'analytic_solution'
            % compute the mean and variance independently. This will mean
            % incorporating the wt fxns seperately for the mean and variance.
            
            % (1) make a spatiotemporal wt fxn. The template will peak at
            % +/- 1 instead of the peak Rstar.
            IRF = ifft(cones.filter_fft);
            IRF = IRF ./ max(IRF);
            IRF = IRF(1:cones.filterSamples);
            wt_spaceTime = makeGaborMovie([1,1,1], gab, mon, 'idlob template', params);
            [wt_spaceTime, ~] = upsampleAndBookend(wt_spaceTime, cones, mon);
            tRange = (cones.nFrontPad+1) : (size(wt_spaceTime,3) - cones.nBackPad);
            wt_spaceTime = wt_spaceTime(:,:, tRange, :); %hack off the bookends.
            wt_spaceTime(:) = 0;
            wt_spaceTime(1,1,:,1) = permute(IRF, [2, 4, 1, 3]);
            
            % (2) calculate the mean response of the ideal observer
            idlOb_mean = bsxfun(@minus, cones.linresp, permute(mon.bkgndlms_pA, [3, 2, 4, 1])); %make the linear response zero mean.
            idlOb_mean = idlOb_mean .* wt_spaceTime;
            idlOb_mean = sum(sum(sum(idlOb_mean,1),2),3); %sum across space. The sum over time is actually part of the dot product with the wt. fxn...
            idlob.analyticMean(clr, cnt) = idlOb_mean(1,1,1,1); % since there's only cones in the Lmosaic, just take the L cone data
            
            % (3) calculate the variance of the ideal observer. This
            % should be the same for each contrast (within color
            % directions) but for now I'm calculating it for each condition
            wt_spaceTime_FFT = fft(wt_spaceTime,[],3); % NOT NORMALIZING, and so I don't need the .* N^2 later...
            noise_fft = bsxfun(@times, wt_spaceTime_FFT, permute(cones.modelNoise_fft, [1,3,2])); % weighting by the space/time/clr fxn in the fft domain
            noise_fft = sum(abs(noise_fft).^2, 3); % variance of a single pixel across time
            noise_fft = squeeze(noise_fft); % remove the (singelton) time dimension 
            numCones = cat(3, cones.num_L, cones.num_M, cones.num_S);
            noise_fft = noise_fft ./ numCones; % the noise is independent from cone to cone (within pixels) so the average var = var(x)/numCones
            idlob.analyticVar(clr, cnt) = noise_fft(1,1,1,1); % since there's only cones in the Lmosaic, only take data from the L-cone mosaic
    end
end

function pooledNoise = pooledNoise_average(cones, DEBUGMODE)
    
    %determine the number of each cone type per pixel    
    numCones = nan([size(cones.num_L), 1, 3]);
    numCones(:,:,1,1) = cones.num_L;
    numCones(:,:,1,2) = cones.num_M;
    numCones(:,:,1,3) = cones.num_S;    

    % In debug mode, store the original variances
    if (nargin==2) && strcmpi(DEBUGMODE, 'unit_test')
        old_var = var(cones.noise, [], 3);
        pool_prediction = bsxfun(@rdivide, old_var, numCones);
    end


    % Calculate the pooled signal and noise. For i.i.d draws:
    % Var(mean(X,Y,...Z)) = N*Var ./ N^2
    % Var(a .* coneNoise) = a^2 .* Var(coneNoise)
    % If a^2 * Var(x) = N*Var ./ N^2.
    % Than  a = sqrt(1/N).
    % For i.i.d draws, the mean of means can be approximated by the sample mean 
    pooledNoise = bsxfun(@times, sqrt(1./numCones), cones.noise); % calculate the variance after pooling
    
    % In debug mode, show that the noise after pooling is what you'd expect
    % based on the pre-pooling variance
    if exist('DEBUGMODE', 'var') && strcmpi(DEBUGMODE, 'unit_test')
        new_var = var(pooledNoise, [], 3);
        figure, hold on,
        pltClr = {'r', 'g', 'b'};
        sym = {'o', '.', 's'};
        for a = 1:3
            plot(pool_prediction(:,:,a), new_var(:,:,a), [sym{a}, pltClr{a}], 'markersize', 10)
        end
        XX = get(gca, 'xlim');
        plot([0, XX(2)], [0, XX(2)], 'k')
        title('Pooled Var: predited vs. computed')
        xlabel('Predicted Variance')
        ylabel('Actual Variance')
        drawnow
    end
end

function saveDataToDisk(gab, cones, mon, idlob, params)
    fprintf('  Saving the data...\n')
    
    % grab the contents of the .m file used to generate the data (i.e.,
    % this file you're reading now)
    pathToDTcones = which('DTcones');
    fid = fopen(pathToDTcones, 'r');
    mfiletext = fscanf(fid, '%c');
    fclose(fid);
    
    %cd to where the data should be stored
    originalDir = pwd;
    newDir = params.saveDir;
    if isempty(newDir)
        if strcmpi(license, '380245'); % charlie's laptop
            newDir = '/Users/charliehass/Dropbox/DTcones/Matlab/Data';
        elseif ~ismac && isunix % shadlen cluster
            newDir = '/home/charlie/data/DT cones';
        end
    end
    cd(newDir)
    
    % make a directory. Make a new one if this is a simple call to DTcones,
    % or make a specific directory (which will be deleted later) if this is
    % called during a parfor loop with a dtnt run.
    if params.parallelOperations
        switch lower(params.runType)
            case 'dtnt'
                sepIdx = regexp(params.DTNT_fname, filesep);
                timestamp = params.DTNT_fname(sepIdx(end)+1 : end);
            case 'dtv1'
                [~, timestamp, ~] = fileparts(params.DTV1_fname);
                
        end
    else
        d = dir;
        suffix = 1;
        timestamp = [date, sprintf('_%d', suffix)];
        alreadyExists = any(strcmpi(timestamp, {d.name}));
        while alreadyExists
            suffix = suffix+1;
            timestamp = [date, sprintf('_%d', suffix)];
            alreadyExists = any(strcmpi(timestamp, {d.name}));
        end
    end
    
    %save the data
    cones.sigPlusNoise = []; % delete the arrays that are unnecessary (and large)
    cones.linresp = [];
    gab.movie = [];
    mkdir(pwd, timestamp)
    cd(timestamp)
    fname_dat = ['out_', timestamp, '.mat'];
    eval(['save ' fname_dat, ' gab cones mon idlob params'])
    
    %save the code of the calling function (i.e., DTcones.m)
    fname_mfile = ['DTcones.m_', timestamp];
    fid = fopen(fname_mfile, 'w');
    fwrite(fid, mfiletext, 'char');
    fclose(fid);
    
    %be nice and cd back to where you came from
    cd(originalDir)
end

%
%   FUNCTIONS USED FOR TESTING
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function callAllTestingSubfunctions(gab, mon, cones, params)

    % redefine the default colors of the gabor (for testing purposes)
    gab.colorDirs = [1 1 1; 1 -1 0];
    gab.contrasts = [{.17}, {.10}];
    
    %
    % run the following testing routines.
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    test_preRetialFiltering(mon);
    test_compareRstarAndRGBgabors(gab, mon, params);
    test_GaborMovie(gab, mon, params, cones)
    test_coneMosaic(cones);
    test_coneVolution_FFTvsConv(gab, mon, cones, params);
    test_shapedConeNoise(cones, gab, mon, params);
    test_impulseResponse(cones, gab, mon, params);
%    
    fprintf('\n\n\n********** TESTING COMPLETE ************\n')
end

function test_GaborMovie(gab, mon, params, cones)

    fprintf('\n\n\n *********** Gabor Movie Test *************\n')
    fprintf('  Theta: %.3f radians\n', gab.theta)
    fprintf('  Spt Freq: %.3f cpd\n', gab.sf)
    fprintf('  Sigma: %.3f tenths DVA\n', gab.sd)
    
    clr = 1;
    cnt = 1;
    LMS_Rstar = getGaborRstar(clr, cnt, gab, mon, params, cones);
    gab.movie = makeGaborMovie(LMS_Rstar, gab, mon, 'movie', params);
    fprintf('  Color dir = [%s]\n', num2str(gab.colorDirs(clr,:)));
    
    figure
    set(gcf, 'position', [21 430 1411 392]);
    fontsize = 16;
    fontname = 'helvetica';
    
    for b = 1:1%size(gab.movie,3)
        subplot(1,3,1)
        tmp = permute(gab.movie(:,:,b,:), [1,2,4,3]);
        L = tmp(:,:,1);
        imagesc(L)
        axis square
        colorbar
        set(gca, 'fontsize', fontsize, 'fontname', fontname);
        title('R* L-Cone Image')
        
        subplot(1,3,2)
        M = tmp(:,:,2);
        imagesc(M)
        axis square
        colorbar
        set(gca, 'fontsize', fontsize, 'fontname', fontname);
        title('R* M-Cone Image')
        xlabel(sprintf('FRAME NUMBER: %d', b))
        
        subplot(1,3,3)
        S = tmp(:,:,3);
        imagesc(S)
        axis square
        colorbar
        set(gca, 'fontsize', fontsize, 'fontname', fontname);
        title('R* S-Cone Image')
        
        %update as fast as possible
        drawnow
    end
    
    
    %show a single frame of Lcc - Mcc image to see how they add. For L-M
    %stimuli, the non-zero component of the sum should be very small
    clr = 2;
    cnt = 1;
    LMS_Rstar = getGaborRstar(clr, cnt, gab, mon, params, cones);
    gab.movie = makeGaborMovie(LMS_Rstar, gab, mon, 'movie', params);
    
    figure
    frame = round(size(gab.movie, 3)./2);
    tmp = permute(gab.movie(:,:,frame,:), [1,2,4,3]);
    Lcc = (tmp(:,:,1) - mon.bkgndlms_Rstar(1))./mon.bkgndlms_Rstar(1);
    Mcc = (tmp(:,:,2) - mon.bkgndlms_Rstar(2))./mon.bkgndlms_Rstar(2);
    imagesc(Lcc+Mcc); %in CC space
    axis square
    colorbar
    set(gca, 'fontsize', fontsize, 'fontname', fontname);
    title('Lcc map + Mcc map (should be low amp for L-M stim)')
    xlabel('Pix X')
    ylabel('Pix Y')
    drawnow
end

function test_compareRstarAndRGBgabors(gab, mon, params)
    %I got nervous that computing the R* for a trial b/4 computing the
    %gabor movie would yield different results than computing the movie in
    %rgb space and then tranforming to R* space. This function compares the
    %two techniques
    
    %determin the rgb/R* to test
    rgb_example = mon.bkgndrgb + [0.4, -0.4, 0];
    LMS_Rstar = mon.rgb2Rstar * rgb_example(:);
    
    %generate the gabors
    gab_Rstar = makeGaborMovie(LMS_Rstar, gab, mon, 'movie', params);
    gab_rgb = makeGaborMovie_rgb(rgb_example, gab, mon);
    
    figure
    hold on,
    maxVal = max([gab_rgb.movie(:); gab_Rstar(:)]);
    minVal = min([gab_rgb.movie(:); gab_Rstar(:)]);
    plot(gab_rgb.movie(:), gab_Rstar(:), '.')
    plot([minVal-100, maxVal+100], [minVal-100, maxVal+100], 'k-')
    title('Gabor_rgb vs. Gabor_Rstar')
    xlabel('Gabor prepared with rgb then transformed to R*')
    ylabel('Gabor prepared directly from R*')
    drawnow
    
    fprintf('\n\n\n********** comparing rgb and R* gabors ************\n')
    fprintf('  All rgb gabor equals R* gabor: %d\n', all(abs(gab_rgb.movie(:) - gab_Rstar(:))<1e-12))
    dif = LMS_Rstar - mon.bkgndlms_Rstar;
    fprintf('  LMS R* = [%.3f, %.3f, %.3f] (diff from bkgnd)\n', dif(1), dif(2), dif(3))
    
    %create a local version of the gabor movie function, but make it operate on
    %rgbs, and then convert to R* (which is opposite the way the main code
    %works)
    function gab = makeGaborMovie_rgb(rgb, gab, mon)

        % Define the constants
        nPix = round((gab.nSd*2) .* (gab.sd./10) .* mon.pixperdeg);
        halfSize = round(nPix./2);
        gaborPhase = 0;
        flashDeltaPhase = gab.driftRate * 2 * pi * (1./mon.frameRate); %the amount to advance each frame
        sigmaInPix = (gab.sd./10) .* mon.pixperdeg;
        lambdaInPix = 1./(gab.sf./mon.pixperdeg);
        rgb_increment = rgb - mon.bkgndrgb;

        % Parameters for ramping on/off stimulus
        flashNumFrames = ceil(mon.frameRate * gab.length);
        rampLength = ceil(flashNumFrames / 4); %in frames
        ramp = linspace(0, 1, rampLength);  %ramp is 1/4th of the total duration on either side
        plateau = ones(1,flashNumFrames - (rampLength .* 2));
        flashTimeProf = [ramp, plateau, fliplr(ramp)];

        % meshgrid for the gabor
        row = -halfSize:halfSize-1; %subtract one so that you don't overlap the texture window;
        col = -halfSize:halfSize-1;
        [X, Y] = meshgrid(row, col);
        xprime = X .* cos(-gab.theta) + Y .* sin(-gab.theta);
        yprime = -X .* sin(-gab.theta) + Y .* cos(-gab.theta);


        % Preallocate space for the movie (4D: [X, Y, Time, Guns])
        gab.movie = nan(size(X,1), size(X,1), flashNumFrames, 3);

        for t = 1:flashNumFrames;

            % Multiply the gabor by the increment from background and by the temporal weighting fxn.
            gabor = exp(-(xprime.^2 + gab.gamma.^2 .* yprime.^2) ./ (2.* sigmaInPix.^2)) .* cos(2 .* pi .* yprime ./ lambdaInPix + gaborPhase);

            %gun intensities b/w 0 and 1
            gab.movie(:,:,t,1) = (gabor .* flashTimeProf(t) .* rgb_increment(1)) + mon.bkgndrgb(1);
            gab.movie(:,:,t,2) = (gabor .* flashTimeProf(t) .* rgb_increment(2)) + mon.bkgndrgb(2);
            gab.movie(:,:,t,3) = (gabor .* flashTimeProf(t) .* rgb_increment(3)) + mon.bkgndrgb(3);

            % Update the phase
            gaborPhase = gaborPhase + flashDeltaPhase;
        end

        %now convert to R* using some complicated reshaping of the gabor matrix
        tmp = reshape(gab.movie, [], 3)';
        tmp = mon.rgb2Rstar * tmp; %converts from rgb to R*
        gab.movie = reshape(tmp', size(gab.movie,1), size(gab.movie,2), flashNumFrames, 3);
    end
end

function test_coneMosaic(cones)

    fprintf('\n\n\n********** plotting the cone mosaic ************\n')
    fprintf('  L/M cones should be equally likely\n')
    fprintf('  S-cone prevalance should be ~10 percent \n')

    N = cones.num_L + cones.num_M + cones.num_S;
    
    figure
    set(gcf, 'position', [8 305 1424 524])
    fontsize = 14;
    
    subplot(2,3,1) %l cone map
    imagesc(cones.num_L)
    colorbar
    set(gca, 'fontsize', fontsize)
    title('Number of L cones by pixel')
    xlabel('pix X')
    ylabel('pix Y')
    
    subplot(2,3,4) % histo of num_L cones per pix
    hist(cones.num_L(:)./N(:))
    set(gca, 'fontsize', fontsize)
    xlabel('Percent L cones per pixel')
    ylabel('Counts')
    
    subplot(2,3,2) %m cone map
    imagesc(cones.num_M)
    colorbar
    set(gca, 'fontsize', fontsize)
    title('Number of M cones by pixel')
    xlabel('pix X')
    ylabel('pix Y')
    
    subplot(2,3,5) % histo of num_M cones per pix
    hist(cones.num_M(:)./N(:))
    set(gca, 'fontsize', fontsize)
    xlabel('Percent M cones per pixel')
    ylabel('Counts')
    
    subplot(2,3,3) %s cone map
    imagesc(cones.num_S)
    colorbar
    set(gca, 'fontsize', fontsize)
    title('Number of S cones by pixel')
    xlabel('pix X')
    ylabel('pix Y')
    
    subplot(2,3,6) % histo of num_S cones per pix
    hist(cones.num_S(:)./N(:))
    set(gca, 'fontsize', fontsize)
    xlabel('Percent S cones per pixel')
    ylabel('Counts')
    
    drawnow
end

function test_coneVolution_FFTvsConv(gab, mon, cones, params)
    
    fprintf('\n\n\n********** comparing FFT-convolution to the real convolution ************\n')
    fprintf('  This should take a moment... \n')
    
    % should the stimulus be an impulse or a regular gabor?
    STIMULUSTYPE = 'gabor'; %for impulse response, set to 'impulse'
    fprintf('  The stimulus type is: %s\n', STIMULUSTYPE);
    
    % make a gabor movie from the default colors at high contrast:
    clr = 1;
    cnt = 1;
    LMS_Rstar = getGaborRstar(clr, cnt, gab, mon, params, cones);
    fprintf('  Color dir = [%s]\n', num2str(gab.colorDirs(clr,:)));
    gab.movie = makeGaborMovie(LMS_Rstar, gab, mon, 'movie', params);
    [cones.linresp, gab.movie] = upsampleAndBookend(gab.movie, cones, mon);
    tmpMovie = cones.linresp; %put the gabor movie into a temporary array
    
    if strcmpi(STIMULUSTYPE, 'impulse')
        tmpMovie(:,:,:,:) = 0;
        idx = ((cones.convLength-cones.nFrontPad-cones.nBackPad)/2) + cones.nFrontPad;
        tmpMovie(:,:,idx,:) = cones.samplingRate;
    end
    
    % resize the movie and filter to the dimesnions appropriate for
    % convolution
    filter = ifft(cones.filter_fft);
    filter = filter(1:(cones.nBackPad+1)); %should be the appropriate length
    filter = filter(:);
    inds = (cones.convLength-cones.nBackPad+1): cones.convLength;
    tmpMovie(:,:,inds,:) = [];
    
    % do the convolution for a random subset of the pixels/cones
    pixIdx = unique(unidrnd(size(tmpMovie,1), [16,2]), 'rows');
    pixIdx(:) = 62;
    coneIdx = unidrnd(3, size(pixIdx,1), 1);
    resp_conv = {};
    for a = 1:size(pixIdx,1) %do the comparison for some randomly selected pixels and cones
        timevec = tmpMovie(pixIdx(a,1), pixIdx(a,2), :, coneIdx(a));
        timevec = timevec(:);
        resp_conv{a} = conv(filter, timevec)./cones.samplingRate;
        resp_conv{a} = resp_conv{a}(cones.nFrontPad+1 : (cones.convLength-cones.nBackPad));
    end
    
    % now do the FFT convolution and compare the resuts to the regular
    % convolution
    cones.linresp = [];
    gab.movie = makeGaborMovie(LMS_Rstar, gab, mon, 'movie', params);
    
    if strcmpi(STIMULUSTYPE, 'impulse')
        [cones, gab] = coneVolution_FFT(gab, cones, mon, 'impulse_response');
    else
        [cones, gab] = coneVolution_FFT(gab, cones, mon);
    end
    
    resp_fft = {};
    for a = 1:size(pixIdx,1)
        resp_fft{a} = cones.linresp(pixIdx(a,1), pixIdx(a,2), :, coneIdx(a));
        resp_fft{a} = resp_fft{a}(:);
    end
    
    %plot the results
    nPlts = ceil(sqrt(size(pixIdx,1)));
    figure
    set(gcf, 'name', 'CONV (black) and FFT (red)')
    for a = 1:size(pixIdx,1)
        subplot(nPlts, nPlts, a)
        hold on,
        plot(resp_fft{a}, 'ro')
        plot(resp_conv{a}, 'k', 'linewidth', 2)
        axis tight
        title(sprintf('Pix: [%d, %d], Cone: %d', pixIdx(a,1), pixIdx(a,2), coneIdx(a)))
    end
    drawnow
    
    %plot the results (diff b/w time and fft conv)
    nPlts = ceil(sqrt(size(pixIdx,1)));
    figure
    set(gcf, 'name', 'CONV - FFT')
    for a = 1:size(pixIdx,1)
        subplot(nPlts, nPlts, a)
        hold on,
        plot(resp_conv{a}-resp_fft{a}, 'b')
        title(sprintf('Pix: [%d, %d], Cone: %d', pixIdx(a,1), pixIdx(a,2), coneIdx(a)))
        axis tight
        hold off
    end
    drawnow
end

function test_shapedConeNoise(cones, gab, mon, params)

    fprintf('\n\n\n********** checking computations of cone noise ************\n')
    fprintf(' This should take a moment... \n')
    
    % make a gabor movie from the default colors at high contrast:
    fprintf('  Setting up a test Gabor stimulus... \n')
    clr = 1;
    cnt = 1;
    LMS_Rstar = getGaborRstar(clr, cnt, gab, mon, params, cones);
    fprintf('  Color dir = [%s]\n', num2str(gab.colorDirs(clr,:)));
    gab.movie = makeGaborMovie(LMS_Rstar, gab, mon, 'movie', params);
    
    % calculate the linear response of the cones
    fprintf('  Calculating the linear response... \n')
    [cones, gab] = coneVolution_FFT(gab, cones, mon);
    
    % now call shapedConeNoise with the optional "testing" argument
    fprintf('  Now adding cone noise... \n')
    cones = shapedConeNoise(cones, gab, 'unit_test');
    
    %demonstrate that caculating the pooled variance gives what you would
    %expect baeed on the variance of the time series before pooling.
    fprintf('  Caculating the pooled variance... \n')
    sigPlusNoise = cones.linresp + pooledNoise_average(cones, 'unit_test');
    
    %plot frames of the cone mosaic response to the stimulus
    figure
    set(gcf, 'position', [10 500 1423 329])
    set(gcf, 'name', 'Cone Mosaic Response (signal + noise)')
    for a = round(linspace(1,size(sigPlusNoise,3),40))
        for i = 1:3
            subplot(1,3,i); imagesc(sigPlusNoise(:,:,a,i)); colorbar
            axis square
        end
        subplot(1,3,2)
        title('response in pA (pooled w/in pixels)', 'fontsize', 14)
        xlabel(sprintf('Frame: %d', a), 'fontsize', 14);
        drawnow
    end
end

function test_preRetialFiltering(mon)

    fprintf('\n\n\n*********** Corneal Fundamentals Test *************\n')
    fprintf('   Compare the SMJ fundamentals to those used here\n')


    %generate the cone action spectra using the wavelengths at which the
    %monitor was calibrated
    actionSpectra(1,:) = coneActionSpectra('LCone',mon.monSpectWavelengths);
    actionSpectra(2,:) = coneActionSpectra('MCone',mon.monSpectWavelengths);
    actionSpectra(3,:) = coneActionSpectra('SCone',mon.monSpectWavelengths);

    %call the function
    preRetinalFiltering(actionSpectra, 'unit_test');
end

function test_impulseResponse(cones, gab, mon, params)

    fprintf('\n\n\n*********** Impulse Response Function Test *************\n')
    fprintf('   compare the model''s impulse response to the simulated IRF\n')
    
    % Simulating the impulse response
    %
    % calculate the linear response to a unit step in Rstar. First,
    % generate a random movie, and then pass it to coneVolution with the
    % optional 'unit_test' argument. This will make a unit step in Rstar
    % from a zero bkgnd.
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    gab.movie = makeGaborMovie(mon.bkgndlms_Rstar, gab, mon, 'movie', params);
    [cones, gab] = coneVolution_FFT(gab, cones, mon, 'impulse_response');
    
    %plot the impulse response    
    figure, hold on,
    stimOnIdx = round(gab.framesInNewGabor./2);
    coneExamp = permute(cones.linresp(1,1, :, 1), [3,1,2,4]);
    coneExamp = coneExamp(stimOnIdx:end);
    tt = ((1:numel(coneExamp))-1)./cones.samplingRate;
    irf = ifft(cones.filter_fft); % I don't think I need to normalize this b/c the filter_fft wasn't normalized...
    irf = irf(1:numel(coneExamp));
    plot(tt, irf, 'ro')
    plot(tt, coneExamp, 'b', 'linewidth', 2)
    set(gca, 'fontsize', 14)
    xlabel('time (sec)')
    ylabel('pico Amps per R star')
    title('Temporal impulse response')
    legend('simulated', 'model')
    drawnow
    
    % TWO: 40 R* in 10ms on 4000 R*/sec Background
    %
    % This is an experiment that juan performed on real cones, and provides
    % a point of comparisons between the actual cones and the model cones.
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    fprintf('   next, test the response to a 4000 R*/sec pulse on a 4000 R*/sec bkgnd\n')
    
    PULSEWIDTH = 0.010; % seconds
    PULSEDELAY = 0.200; % seconds after stim on to position the pulse
    PULSEBKGND = 4000;  % in R*/sec
    PULSEHEIGHT = 40;   % in R*... NOT R*/sec!!!!
    
    
    % convert the pulseheight to R*/sec during the pulse... and to
    % accomodate for the new sampling rate.
    effectiveRStarPerSec = ((PULSEBKGND .* PULSEWIDTH) +  PULSEHEIGHT) ./ PULSEWIDTH;
    effectivePulseWidth = ceil(PULSEWIDTH.*mon.frameRate) .* (cones.samplingRate./mon.frameRate) ./ cones.samplingRate
    
    % make a gabor movie and then change it to make the pulse step.
    gab.movie = makeGaborMovie(mon.bkgndlms_Rstar, gab, mon, 'movie', params);
    gab.movie(:) = PULSEBKGND;
    tvec = [0:size(gab.movie,3)-1] ./ mon.frameRate;
    ton_idx = find(tvec > PULSEDELAY,1, 'first');
    nFramesOn = ceil(PULSEWIDTH .* mon.frameRate);
    gab.movie(:,:,[ton_idx : (ton_idx+nFramesOn-1)],:) = effectiveRStarPerSec;
    
    % re-estimate the cone linear response to the new bkgnd.
    mon.bkgndlms_Rstar(:) = PULSEBKGND;
    mon = getBkgndLinearResp(cones, mon);
    
    % run the conevolutions and estimate the cone noise
    [cones, gab] = coneVolution_FFT(gab, cones, mon);
    cones = shapedConeNoise(cones, gab);
    resp = cones.linresp + cones.noise;   
    
    
    % plot some of the results
    nExamps = 10; % the number of example traces
    pixels = [unidrnd(size(cones.noise,1), nExamps,1), unidrnd(size(cones.noise,2), nExamps,1), unidrnd(size(cones.noise,4), nExamps,1)];
    space = 20;
    cone_tvec = [0:(size(cones.linresp,3)-1)] ./ cones.samplingRate;
    
    % single trial examples
    figure, hold on
    for a = 1:nExamps
        tmp = permute(resp(pixels(a,1), pixels(a,2), :, pixels(a,3)), [3,1,2,4]);
        yy = ((a-1).*space) + tmp;
        plot(cone_tvec, yy, 'k')
    end
    % add the example stimulus
    t_pulse = [ton_idx : (ton_idx+nFramesOn)]./ mon.frameRate;
    yy = (mean(tmp)+(a*space)) .* ones(1,numel(t_pulse));
    plot(t_pulse, yy, 'b', 'linewidth', 3)
    xlabel('Time (sec)')
    ylim([mean(tmp)-space, yy(1)+10])
    xlim([0, (size(resp,3)-1) ./ cones.samplingRate])
    set(gcf, 'position', [397 5 447 824])
    %set(gca, 'yticklabel', [])
    title(sprintf('Response to %d R* pulse', PULSEHEIGHT))
    drawnow

    % plot the mean of the cone signal+noise
    figure, hold on,
    set(gca, 'fontsize', 14)
    r = [];
    for a = 1:3
        tmp = resp(:,:,:,a);
        tmp = permute(tmp, [3, 1, 2]);
        tmp = reshape(tmp, size(resp,3), []);
        r = [r,tmp];
    end
    r = mean(r,2);
    plot(cone_tvec, r, 'k');
    yy = (max(r).*1.01) .* ones(1,numel(t_pulse));
    plot(t_pulse, yy, 'b', 'linewidth', 3)
    xlim([0, cone_tvec(end)])
    xlabel('Time (sec)')
    ylabel('Pico Amps')
    drawnow
    
end













